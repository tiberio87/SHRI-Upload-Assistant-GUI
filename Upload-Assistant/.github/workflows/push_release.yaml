name: Create Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., v1.2.3)'
        required: true
        type: string
      previous_version:
        description: 'Previous version for changelog (leave empty for auto-detect)'
        required: false
        type: string

jobs:
  create-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Get full history for changelog generation
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Validate version format
        run: |
          VERSION="${{ github.event.inputs.version }}"
          if [[ ! $VERSION =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "‚ùå Invalid version format. Use format: v1.2.3"
            exit 1
          fi
          echo "VERSION=${VERSION}" >> $GITHUB_ENV
          echo "VERSION_NUMBER=${VERSION#v}" >> $GITHUB_ENV

      - name: Check if tag already exists
        run: |
          if git tag -l "${{ env.VERSION }}" | grep -q "${{ env.VERSION }}"; then
            echo "‚ùå Tag ${{ env.VERSION }} already exists!"
            exit 1
          fi

      - name: Get previous tag for changelog
        run: |
          if [ -n "${{ github.event.inputs.previous_version }}" ]; then
            PREVIOUS_TAG="${{ github.event.inputs.previous_version }}"
          else
            PREVIOUS_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          fi
          
          if [ -z "$PREVIOUS_TAG" ]; then
            echo "PREVIOUS_TAG=initial" >> $GITHUB_ENV
          else
            echo "PREVIOUS_TAG=${PREVIOUS_TAG}" >> $GITHUB_ENV
          fi
          echo "üìù Previous tag: ${PREVIOUS_TAG:-'none (first release)'}"

      - name: Fetch changelog from local file
        run: |
          # Path to the local changelog file
          CHANGELOG_FILE="data/Upload-Assistant-release_notes.md"
    
          echo "üîç Attempting to read changelog from: $CHANGELOG_FILE"
    
          # Check if the file exists and read it
          if [ -f "$CHANGELOG_FILE" ]; then
            # Read the file content
            GIST_CONTENT=$(cat "$CHANGELOG_FILE")
      
            # Check if content is not empty
            if [ -n "$GIST_CONTENT" ] && [ ${#GIST_CONTENT} -gt 10 ]; then
              echo "‚úÖ Successfully read content from local file"
        
              # Get the first line and check if it matches the version
              FIRST_LINE=$(echo "$GIST_CONTENT" | head -n 1)
              echo "üîç First line of file: '$FIRST_LINE'"
              echo "üîç Expected version: '${{ env.VERSION }}'"
        
              # Check if first line matches the version (with or without markdown formatting)
              if [[ "$FIRST_LINE" == "${{ env.VERSION }}" ]] || [[ "$FIRST_LINE" == "# ${{ env.VERSION }}" ]] || [[ "$FIRST_LINE" == "## ${{ env.VERSION }}" ]]; then
                echo "‚úÖ First line matches version, removing it and using rest of content"
                # Remove the first line and use the rest
                PROCESSED_CONTENT=$(echo "$GIST_CONTENT" | tail -n +2)
              else
                echo "‚ö†Ô∏è First line doesn't match version '${{ env.VERSION }}', skipping file content"
                PROCESSED_CONTENT=""
              fi
        
              # Only set the changelog if we have processed content
              if [ -n "$PROCESSED_CONTENT" ] && [ ${#PROCESSED_CONTENT} -gt 5 ]; then
                echo "‚úÖ Using local file changelog content"
                # Save to environment variable
                {
                  echo "GIST_CHANGELOG<<EOF"
                  echo "$PROCESSED_CONTENT"
                  echo ""
                  echo "---"
                  echo ""
                  echo "EOF"
                } >> $GITHUB_ENV
              else
                echo "‚ö†Ô∏è No valid content after processing, skipping file"
                echo "GIST_CHANGELOG=" >> $GITHUB_ENV
              fi
            else
              echo "‚ö†Ô∏è File content appears to be empty or too short, skipping"
              echo "GIST_CHANGELOG=" >> $GITHUB_ENV
            fi
          else
            echo "‚ö†Ô∏è Changelog file '$CHANGELOG_FILE' not found, continuing without it"
            echo "GIST_CHANGELOG=" >> $GITHUB_ENV
          fi

      - name: Generate changelog from merged PRs and commits
        run: |
          if [ "${{ env.PREVIOUS_TAG }}" = "initial" ]; then
            # For first release, get all commits since beginning
            COMMIT_RANGE=""
          else
            # Get commits since previous tag
            COMMIT_RANGE="${{ env.PREVIOUS_TAG }}..HEAD"
          fi
          
          # Create changelog
          {
            echo "CHANGELOG<<EOF"
            
            # Add Gist content at the top if it exists
            if [ -n "${{ env.GIST_CHANGELOG }}" ]; then
              echo "${{ env.GIST_CHANGELOG }}"
            fi
            
            echo "## What's Changed"
            echo ""
            
            # Get commits in chronological order
            if [ -z "$COMMIT_RANGE" ]; then
              COMMITS=$(git log --pretty=format:"%H|%an|%s" --reverse)
            else
              COMMITS=$(git log $COMMIT_RANGE --pretty=format:"%H|%an|%s" --reverse)
            fi
            
            # Track if we found any changes
            FOUND_CHANGES=false
            
            # Process each commit
            echo "$COMMITS" | while IFS='|' read -r COMMIT_HASH AUTHOR SUBJECT; do
              # Skip empty lines
              [ -z "$COMMIT_HASH" ] && continue
              
              # Handle PR merge commits
              if [[ $SUBJECT =~ ^Merge\ pull\ request\ #([0-9]+)\ from\ (.+) ]]; then
                PR_NUMBER="${BASH_REMATCH[1]}"
                BRANCH_INFO="${BASH_REMATCH[2]}"
                
                # Get PR title from GitHub API
                PR_TITLE=$(curl -s \
                  -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                  -H "Accept: application/vnd.github.v3+json" \
                  "https://api.github.com/repos/${{ github.repository }}/pulls/${PR_NUMBER}" \
                  | jq -r '.title // empty')
                
                # Get PR author from GitHub API
                PR_AUTHOR=$(curl -s \
                  -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                  -H "Accept: application/vnd.github.v3+json" \
                  "https://api.github.com/repos/${{ github.repository }}/pulls/${PR_NUMBER}" \
                  | jq -r '.user.login // empty')
                
                # Use PR title if available, otherwise use branch name
                if [ -n "$PR_TITLE" ] && [ "$PR_TITLE" != "null" ]; then
                  TITLE="$PR_TITLE"
                else
                  # Clean up branch name for display
                  TITLE=$(echo "$BRANCH_INFO" | sed 's|.*/||' | sed 's|-| |g' | sed 's/_/ /g')
                fi
                
                # Use PR author if available, otherwise use commit author
                if [ -n "$PR_AUTHOR" ] && [ "$PR_AUTHOR" != "null" ]; then
                  DISPLAY_AUTHOR="@$PR_AUTHOR"
                else
                  DISPLAY_AUTHOR="@$AUTHOR"
                fi
                
                # Map known username variations
                case "$DISPLAY_AUTHOR" in
                  "@flower"|"@Flower") DISPLAY_AUTHOR="@flowerey" ;;
                  # Add other mappings as needed
                  # "@oldname") DISPLAY_AUTHOR="@newname" ;;
                esac
                
                echo "* ${TITLE} by ${DISPLAY_AUTHOR} in https://github.com/${{ github.repository }}/pull/${PR_NUMBER}"
                FOUND_CHANGES=true
                
              # Handle direct branch merges
              elif [[ $SUBJECT =~ ^Merge\ branch\ \'([^\']+)\' ]]; then
                BRANCH_NAME="${BASH_REMATCH[1]}"
                
                # Clean up branch name for display
                CLEAN_BRANCH=$(echo "$BRANCH_NAME" | sed 's|-| |g' | sed 's/_/ /g')
                
                # Apply username mapping to commit author as well
                MAPPED_AUTHOR="@$AUTHOR"
                case "$MAPPED_AUTHOR" in
                  "@flower"|"@Flower") MAPPED_AUTHOR="@flowerey" ;;
                esac
                
                echo "* Merge branch '${BRANCH_NAME}' by ${MAPPED_AUTHOR}"
                FOUND_CHANGES=true
                
              # Handle direct commits (non-merge commits that might be significant)
              elif [[ ! $SUBJECT =~ ^Merge ]]; then
                # Skip version update commits and other automated commits
                if [[ ! $SUBJECT =~ ^Update\ version\.py ]] && [[ ! $SUBJECT =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]] && [[ ! $AUTHOR =~ github-actions ]]; then
                  # Only include if it looks like a meaningful change
                  if [[ $SUBJECT =~ ^(feat|fix|add|update|improve|remove|refactor): ]] || [[ ${#SUBJECT} -gt 10 ]]; then
                    # Apply username mapping to commit author
                    MAPPED_AUTHOR="@$AUTHOR"
                    case "$MAPPED_AUTHOR" in
                      "@flower"|"@Flower") MAPPED_AUTHOR="@flowerey" ;;
                    esac
                    
                    echo "* ${SUBJECT} by ${MAPPED_AUTHOR} in ${COMMIT_HASH:0:7}"
                    FOUND_CHANGES=true
                  fi
                fi
              fi
            done

            echo ""
            if [ "${{ env.PREVIOUS_TAG }}" != "initial" ]; then
              echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/${{ env.PREVIOUS_TAG }}...${{ env.VERSION }}"
            else
              echo "**Full Changelog**: https://github.com/${{ github.repository }}/commits/${{ env.VERSION }}"
            fi
            echo "EOF"
          } >> $GITHUB_ENV

      - name: Update version.py
        run: |
          TIMESTAMP=$(date +"%Y-%m-%d")
          VERSION_FILE="data/version.py"

          # Create version.py if it doesn't exist
          if [ ! -f "$VERSION_FILE" ]; then
            echo "__version__ = \"0.0.0\"" > "$VERSION_FILE"
            echo "" >> "$VERSION_FILE"
          fi

          # Update version and prepend new release info
          TEMP_FILE=$(mktemp)
          
          # Start with the NEW version (maintaining 'v' prefix format)
          echo "__version__ = \"${{ env.VERSION }}\"" > "$TEMP_FILE"
          echo "" >> "$TEMP_FILE"
          echo "\"\"\"" >> "$TEMP_FILE"
          echo "Release Notes for version ${{ env.VERSION }} ($TIMESTAMP):" >> "$TEMP_FILE"
          echo "" >> "$TEMP_FILE"
          cat <<EOF | sed 's/^/# /' >> "$TEMP_FILE"
          ${{ env.CHANGELOG }}
          EOF
          echo "\"\"\"" >> "$TEMP_FILE"
          echo "" >> "$TEMP_FILE"
          
          # Add the rest of the existing file (skip first line since we're replacing it)
          if [ -f "$VERSION_FILE" ]; then
            tail -n +2 "$VERSION_FILE" >> "$TEMP_FILE"
          fi
          mv "$TEMP_FILE" "$VERSION_FILE"

      - name: Commit version update
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git add data/version.py
          
          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "${{ env.VERSION }}"
            echo "‚úÖ Committed version.py update with message: ${{ env.VERSION }}"
          fi

      - name: Create and push tag
        run: |
          # Create the tag on the commit that includes the version update
          git tag -a "${{ env.VERSION }}" -m "${{ env.VERSION }}"
          
          # Push the commit and tag
          git push origin HEAD:${{ github.event.repository.default_branch }}
          git push origin "${{ env.VERSION }}"
          
          echo "‚úÖ Created and pushed tag: ${{ env.VERSION }}"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ env.VERSION }}
          name: "${{ env.VERSION }}"
          body: ${{ env.CHANGELOG }}
          draft: false
          prerelease: false
          generate_release_notes: false  # Use only our custom changelog
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Output release information
        run: |
          echo "‚úÖ Release ${{ env.VERSION }} created successfully!"
          echo "üìù Release URL: https://github.com/${{ github.repository }}/releases/tag/${{ env.VERSION }}"
          echo "üìÑ Version file updated and committed with tag: ${{ env.VERSION }}"
          echo "üè∑Ô∏è Tag includes the version commit"

      - name: Trigger Docker build
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'docker-image.yml',
              ref: '${{ env.VERSION }}'
            });
            console.log('üê≥ Triggered Docker workflow for tag: ${{ env.VERSION }}');
